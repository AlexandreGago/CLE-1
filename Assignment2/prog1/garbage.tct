        //MANEIRA 1 RECEIVE CHUNK NO WORKER
        //?maneira 1
        // Chunk received_chunk;
        // int header_size = sizeof(Chunk);
        // memcpy(&received_chunk, recv_buffer, header_size);

        // // Allocate memory for the data field and copy its contents
        // received_chunk.data = malloc(incoming_size - header_size + 1); // allocate space for null terminator
        // memcpy(received_chunk.data, recv_buffer + header_size, incoming_size - header_size); // copy data
        // // received_chunk.data[incoming_size - header_size] = '\0'; // set null terminator


                //?maneira 2 - mais intuitiva, idk which is better 
        // Chunk* received_chunk = (Chunk*)recv_buffer;
        // // Allocate a separate buffer for the data field
        // unsigned char* data_buffer = (unsigned char*)malloc(received_chunk->size+1);

        // // Copy the data field from the receive buffer to the data buffer
        // memcpy(data_buffer, recv_buffer + sizeof(Chunk), received_chunk->size);
        // //null terminate the data buffer
        // data_buffer[received_chunk->size] = '\0';

        // // Set the data field of the received_chunk to point to the data buffer
        // received_chunk->data = data_buffer;



//DISTRIBUTOR CHUNK malloc

        //malloc the buffer
        if ((chunk.data = malloc(chunkSize)) == NULL) {
            printf("Error allocating memory for Chunk\n");
            exit(EXIT_FAILURE);
        }
        if (memset(chunk.data, 0, chunkSize) == NULL) {
            printf("Error clearing memory in Chunk\n");
            exit(EXIT_FAILURE);
        }



        int clearChunk(Chunk *chunk){
    chunk->size = 0;
    chunk->nWords = 0;
    chunk->FileId = -1;
    if (memset(chunk->data, 0, chunkSize) == NULL) {
        printf("Error clearing Chunk\n");
        exit(EXIT_FAILURE);
    }
    for (int j = 0; j < 6; j++) {
        chunk->nVowels[j] = 0;
    }
    return EXIT_SUCCESS;
}